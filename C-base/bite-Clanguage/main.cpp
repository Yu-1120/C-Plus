#include <iostream>
#include <assert.h>
#include <time.h>
// 1--时间复杂度和空间复杂度计算
//****************************************
// 1.什么是时间复杂度和空间复杂度？
// 2.如何计算常见算法的时间复杂度和空间复杂度？
// 3.有复杂度要求的算法题练习
//****************************************
// 1.什么是时间复杂度和空间复杂度？
// 1.1算法效率
// 算法效率分析分为两种：第一种是时间效率，第二种是空间效率。时间效率被称为时间复杂度，
// 而空间效率被称作空间复杂度。 时间复杂度主要衡量的是一个算法的运行速度，而空间复杂度主
// 要衡量一个算法所需要的额外空间，在计算机发展的早期，计算机的存储容量很小。所以对空间
// 复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。
// 所以我们如今已经不需要再特别关注一个算法的空间复杂度。
// 1.2 时间复杂度的概念
// 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运
// 行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机
// 器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻
// 烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比
// 例，算法中的基本操作的执行次数，为算法的时间复杂度。
// 1.3 空间复杂度的概念
// 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。空间复杂度不是程序占用
// 了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计
// 算规则基本跟实践复杂度类似，也使用大O渐进表示法。

//****************************************
int cal_time()
{
    for (int i = 0; i < 10000; i++)
    {
        printf("hello word\n");
    }

    printf("Time used = %.2lf\n", (double)clock() / CLOCKS_PER_SEC);
    // for (int i = 0; i < 10000; i++)----->花费了8.23秒
}
//****************************************
long long *Fibonacci(size_t n)
{
    if (n == 0)
        return NULL;
    long long *fibArray = (long long *)malloc((n + 1) * sizeof(long long));
    fibArray[0] = 0;
    fibArray[1] = 1;
    for (int i = 2; i <= n; ++i)
    {
        fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
    }
    return fibArray;
}
// 计算阶乘递归Factorial的空间复杂度？
long long Factorial(size_t N)
{
    return N < 2 ? N : Factorial(N - 1) * N;
}
int main()
{
    // Fibonacci(1314);
    Factorial(123123);
    return 0;
}
